<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 7.5.5.2 (Linux)"/>
	<meta name="created" content="2023-06-08T14:23:31.005465672"/>
	<meta name="changed" content="2023-08-15T22:55:41.122612309"/>
	<style type="text/css">
		@page { size: 8.27in 11.69in; margin: 0.79in }
		p { line-height: 115%; margin-bottom: 0.1in; background: transparent }
		h1 { margin-bottom: 0.08in; background: transparent; page-break-after: avoid }
		h1.western { font-family: "Liberation Sans", sans-serif; font-size: 18pt; font-weight: bold }
		h1.cjk { font-family: "Source Han Sans CN"; font-size: 18pt; font-weight: bold }
		h1.ctl { font-family: "Droid Sans Devanagari"; font-size: 18pt; font-weight: bold }
		h2 { margin-top: 0.14in; margin-bottom: 0.08in; background: transparent; page-break-after: avoid }
		h2.western { font-family: "Liberation Sans", sans-serif; font-size: 16pt; font-weight: bold }
		h2.cjk { font-family: "Source Han Sans CN"; font-size: 16pt; font-weight: bold }
		h2.ctl { font-family: "Droid Sans Devanagari"; font-size: 16pt; font-weight: bold }
		h3 { margin-top: 0.1in; margin-bottom: 0.08in; background: transparent; text-decoration: underline; page-break-after: avoid }
		h3.western { font-family: "Liberation Sans", sans-serif; font-size: 12pt; font-weight: normal }
		h3.cjk { font-family: "Source Han Sans CN"; font-size: 12pt; font-weight: normal }
		h3.ctl { font-family: "Droid Sans Devanagari"; font-size: 12pt; font-weight: normal }
		h4 { margin-top: 0.08in; margin-bottom: 0.08in; background: transparent; text-decoration: underline; page-break-after: avoid }
		h4.western { font-family: "Liberation Sans", sans-serif; font-size: 12pt; font-style: italic; font-weight: normal }
		h4.cjk { font-family: "Source Han Sans CN"; font-size: 13pt; font-style: italic; font-weight: bold }
		h4.ctl { font-family: "Droid Sans Devanagari"; font-size: 13pt; font-style: italic; font-weight: bold }
		a:link { color: #000080; text-decoration: underline }
	</style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr"><h1 class="western">
Anpassen der LUNTE Daten</h1>
<p>Um die Wirkungsquerschnitte beider Experimente vergleichen zu
können, müssen die Panoramas die selben Dimensionen haben. Dafür
müssen die Daten (Bilder und csv-Dokumente) des LUNTE Experiments
verkleinert werden. Dabei ist darauf zu achten, dass die totale
Pixelfläche, auf denen SEL detektiert wurden relativ zur
Gesamtfläche konstant bleibt. Es dürfen also keine Pixel verloren
gehen, wodurch Standardlösungen aus Bilbliotheken wie <i>scipy</i>
oder <i>numpy</i> ungeeignet sind. Des weiteren muss für den Fall,
dass mehrere Pixel, in denen SEL detektiert wurden, auf dasselbe
Pixel gemappt werden sichergetellt werden, dass hier ein Minimalwert
(größer 0) eingetragen wird, um die Latch-Up-Schwelle nicht zu
verfälschen.</p>
<p>Zur Berechnung des Wirkungsquerschnitts der LUNTE Daten wird ein
vorhandenes Skript von Dr.-Ing. Hannes Zöllner verwendet. Um die
beiden Datensätze vergleichbar zu machen müssen vier Schritte
ausgeführt werden bevor das Skript ausgeführt werden kann:</p>
<ol>
	<li><p>Panoramas zusammen setzen</p>
	<li><p>Größe ändern (Pixel Binning)</p>
	<li><p>Überlappende Pixel Löschen</p>
	<li><p>Streifen zusammenfügen</p>
</ol>
<h2 class="western"><a name="__RefHeading___Toc1100_1211417065"></a>Panoramas
zusammen setzen</h2>
<p><a name="__RefHeading___Toc1102_1211417065"></a>Die Panoramas
werden aus den Bildern genau wie die GSI-Bilder manuell zusammen
gesetzt und so eng wie möglich auf die Größe des Chips
zugeschnitten.</p>
<h2 class="western"><a name="__RefHeading___Toc1104_1211417065"></a>Größe
ändern</h2>
<h3 class="western">Lösungsalgorithmus</h3>
<p>Nachdem die Skalierungsfaktoren berechnet und die csv-Datei
eingelesen wurde, werden sie an die Funktion
<i>custom_binning_smallest_value</i><i>()</i> zur weiteren
Verarbeitung gegeben. Dabei werden 3 verschiedene Schritte
ausgeführt:</p>
<ol>
	<li><p>Berechnen der neuen Dimensionen und erstellen eines
	entsprechenden Arrays.</p>
</ol>
<p>Für jedes Pixel im neuen Array:</p>
<ol start="2">
	<li><p>Berechnen welche Pixel des originalen Arrays (Bereich) mit
	dem aktuellen Pixel korrespondieren 
	</p>
	<li><p>Extraktion der Minimalwerte größer 0 aus dem Bereich und
	Speichern im neuen Array</p>
	<p></p>
</ol>
<h4 class="western">Berechnen der neuen Dimensionen und erstellen
eines entsprechenden Arrays</h4>
<p>Um die neuen Dimensionen zu berechnen, werden die Dimensionen des
Originalarray mit dem jeweiligen Skalierungsfaktor multipliziert und
in einer Liste<i> new_shape </i><span style="font-style: normal">gepeichert.
Damit kann dann mithilfe der Funktion </span><i>numpy.zeros(new_shape)</i><span style="font-style: normal">
ein neuer Array mit den neuen Dimensionen und mit Nullen gefüllt
erstellt werden. </span>
</p>
<h4 class="western">Berechnen welche Pixel des originalen Arrays mit
dem aktuellen Pixel korrespondieren 
</h4>
<p>Für jedes Pixel in dem neuen Array wird berechnet, mit welchen
Pixeln des originalen Arrays es korrespondiert. Dazu wird der Index
entlang jeder Achse mit dem entsprechenden  Skalierungsfaktor
dividiert. Dadurch wird die Skalierung rückgängig gemacht und die
Position im originalen Array wird zurückgegeben.</p>
<p>				<img src="chapter3_html_91b8d6546112d2ad.gif" name="Object11" width="246" height="40"/>
</p>
<p style="font-style: normal">Um den Bereich einzugrenzen fehlt noch
ein Endwert. Dieser wird mit der Formel</p>
<p>				<img src="chapter3_html_ed3d4de991f32018.gif" name="Object12" width="247" height="40"/>
</p>
<p>berechnet.</p>
<p>Mit den Start und Endpixeln kann nun ein Ausschnitt des
Originalarrays extrahiert werden, der in dem neuen Array zu einem
Pixel zusammengesetzt wird. 
</p>
<h4 class="western">Extraktion der Minimalwerte größer 0 aus dem
Bereich und Speichern im neuen Array</h4>
<p>In dem Ausschnitt kann nun der Minimalwert größer Null ( 
<img src="chapter3_html_aa790bdaddab6c72.gif" name="Object13" width="166" height="19"/>
)
gefunden werden und in das neue Array eingesetzt werden. Wenn das auf
keinen der Werte zutrifft, bleibt das Pixel Null. 
</p>
<h3 class="western">Auswertung und Bewertung des Algorithmus</h3>
<p>Um bewerten zu können, ob die Funktion die Vorgaben erfüllt und
wird die csv-Datei: 20230606-124422_t.csv als Array eingelesen und
dann um die Faktoren 
</p>
<p>	x: 0.8266033254156769 
</p>
<p>	y: 0.7913486005089059 
</p>
<p>(original Skalierungsfaktoren bei Verwendung des von mir
erstellten GSI-Panoramas) verkleinert.</p>
<p>Das Ergebnis wird mit zwei Methoden überprüft:</p>
<ol>
	<li><p>Vergleich der relativen aktiven Fläche</p>
	<li><p>Exportieren als Bild</p>
</ol>
<h4 class="western">Vergleich der relativen aktiven Fläche</h4>
<p>Um die relativen aktiven Flächen zu vergleichen, wurden für
beide Arrays alle SEL (Werte &gt;0) gezählt und dann durch die
Gesamtzahl aller Werte dividiert. Das liefert folgende Ergebnisse</p>
<p>	<i><b>original:  	0,014004811633939492</b></i></p>
<p><i><b>	verkleinert:	0,014512083097795364</b></i></p>
<p>Im verkleinerten Bild zeigt sich, dass ein größerer Anteil der
Fläche, nämlich ungefähr 0,05% der Gesamtfläche mehr, aktiv ist.
Das entspricht einem Zuwachs von ca. 3,6% bezogen auf die relative
aktive Fläche im original Array.</p>
<h4 class="western">Exportieren als Bild</h4>
<p>Es werden sowohl das originale als auch das neue Array mit Hilfe
der OpenCV Funktion <i>cv2.imwrite() </i><span style="font-style: normal">als
Bilder </span><span style="font-style: normal">e</span><span style="font-style: normal">xportiert.
Dadurch können die Arrays besser visuell verglichen werden.</span></p>
<p><span id="Frame1" dir="ltr" style="float: left; width: 1.09in; border: none; padding: 0in; background: #ffffff"><p style="line-height: 100%; margin-top: 0.08in; margin-bottom: 0.08in">
	<img src="chapter3_html_ebc89de6ebe2f90.png" name="Image1" align="left" width="100%" height="auto">
  <br clear="left"/>
</img>
<font size="3" style="font-size: 12pt"><i>Figure
	<span style="background: #c0c0c0">1</span>: original Version</i></font></p>
</span>
<span id="Frame2" dir="ltr" style="float: left; width: 1.03in; border: none; padding: 0in; background: #ffffff"><p style="line-height: 100%; margin-top: 0.08in; margin-bottom: 0.08in">
	<img src="chapter3_html_afefe276d848633d.png" name="Image2" align="left" width="100%" height="auto">
  <br clear="left"/>
</img>
<font size="3" style="font-size: 12pt"><i>Figure
	<span style="background: #c0c0c0">2</span>: Verkleinerte Version</i></font></p>
</span>
<span id="Frame5" dir="ltr" style="float: left; width: 1.1in; border: none; padding: 0in; background: #ffffff"><p style="line-height: 100%; margin-top: 0.08in; margin-bottom: 0.08in">
	<img src="chapter3_html_25248c519f64d952.png" name="Image5" align="left" width="100%" height="auto">
  <br clear="left"/>
</img>
<font size="3" style="font-size: 12pt"><i>Figure
	<span style="background: #c0c0c0">3</span>: LUNTE Bilddaten</i></font></p>
</span><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p style="font-style: normal"><br/>
<br/>

</p>
<p><span style="font-style: normal">Auf den ersten Blick sehen beide
Bilder sehr ähnlich aus und weisen die selben Strukturen auf. Das
deuted daraufhin, dass die Funktion grundsätzlich funktioniert.
Jetzt muss noch geprüft werden, ob einzelne Pixel auch bestehen
bleiben oder ‘verschluckt’ werden. Dazu wird ein Cluster von
Pixeln im o</span><span style="font-style: normal">b</span><span style="font-style: normal">eren
Viertel des Original Bildes ausgewählt und mit dem
korrespondierenden Bereich im verkleinerten Bild verglichen.</span></p>
<p><span id="Frame3" dir="ltr" style="float: left; width: 1.11in; border: none; padding: 0in; background: #ffffff"><p style="line-height: 100%; margin-top: 0.08in; margin-bottom: 0.08in">
	<img src="chapter3_html_bf09807401d7161e.png" name="Image3" align="left" width="100%" height="auto">
  <br clear="left"/>
</img>
<font size="3" style="font-size: 12pt"><i>Figure
	<span style="background: #c0c0c0">5</span>: original Version</i></font></p>
</span>
<span id="Frame4" dir="ltr" style="float: left; width: 16%; border: none; padding: 0in; background: #ffffff"><p style="line-height: 100%; margin-top: 0.08in; margin-bottom: 0.08in">
	<img src="chapter3_html_eca36da5e22a4b2e.png" name="Image4" align="left" width="100%" height="auto">
  <br clear="left"/>
</img>
<font size="3" style="font-size: 12pt"><i>Figure
	<span style="background: #c0c0c0">4</span>: verkleinerte Version</i></font></p>
</span><br clear="left"><br/>
<br/>

</p>
<p style="font-style: normal">Auch diese Ausschnitte sehen sehr
ähnlich aus. Auch einzelne Pixel werden nicht ‘verschluckt’ und
bleiben auch im verkleinerten Datensatz als Datenpunkt bestehen.</p>
<h2 class="western" style="page-break-before: always"><a name="__RefHeading___Toc1106_1211417065"></a>
Überlappende Pixel Löschen</h2>
<p>Um herauszufinden, wie viele Pixel-Spalten sich überlappen werden
die skalierten Bilder zu einem Panorama zusammengefügt und dann so
zugeschnitten , dass nur die sich überlappenden Bereiche übrig
bleiben. Diese können gezählt und anschließend die selbe Breite am
rechten und linken Rand der csv-Datei löschen. Eine eventuelle
verschiebung entlang der y-Achse hat keinen Einflüss auf die
Berechnung des Wirkungsquerschnitts.</p>
<h2 class="western"><a name="__RefHeading___Toc1108_1211417065"></a>Csv
Dateien zusammen fügen</h2>
<p style="font-style: normal">Zum Zusammenfügen der csv-Dateien
werden diese im ersten Schritt eingelesen, und die Dimensionen der
einzelnen Arrays ermittelt. Die Dokumente werden Reihenweise
zusammengefügt, wenn es zu unterschieden in der länge der Arrays
kommt werden diese mit Nullen (0) aufgefüllt. Der so entstandene
Array wird in eine csv-Datei geschrieben und im Unterordner ‘resized’
gespeichert.</p>
<div title="footer"><p align="center" style="line-height: 100%; margin-top: 0.2in; margin-bottom: 0in">
	<span style="background: #c0c0c0"><sdfield type=PAGE subtype=RANDOM format=PAGE>4</sdfield></span></p>
</div>
</body>
</html>